---
title: "Stage: Projet 1"
title-block-banner: images/clipboard-7304765.png
subtitle: "House Prices - Advanced Regression Techniques"
date: last-modified
author: 
  - name: Tra Bi Nene Othniel
  - email: bineneothniel.tra@linkpact.fr
  - url: 
keywords: 
  - R for data-science
  - regression techniques
  - machine learning
format: html
  
filters:
  - webr
  - shinylive
editor_options: 
  chunk_output_type: inline
---

```{r}
categorical_corelation(train )
cat_corelation_heatmap(train  )
```


# Importation des données

```{r}
#| file: fonctions.R
#| echo: true


train <- read.csv("data/train.csv", na.strings = "NA")
test <- read.csv("data/test.csv", na.strings = "NA")


label <- train$SalePrice
Id <- test$Id

a <- train %>% 
  dplyr::select(-SalePrice) %>%
  mutate( type = "train")

b <- test %>%
  mutate( type = "test")


data <- bind_rows(a, b)
```

utilisons DataExplorer pour rapidement explorer notre base de donnée,

```{r}
introduce(train)
```

```{r}
#| eval: false
create_report(
  train,
  output_format =rmarkdown::html_document(toc = TRUE, toc_depth = 6, theme = "yeti"),
  output_file = "report.html",
  output_dir = getwd(),
  y = "SalePrice",
  config = configure_report(),
  report_title = "Data Profiling Report")
```

on remarque que que certaine section n'ont pas eté affichée à cause de la présence de valeur manquante.

```{r}
data %>%
  slice_head(n = 12) %>%
  gt_trabi() %>%
  tab_source_note(md("Source : kaggle"))
```

```{r}
#| code-fold: show 
skimr::skim(data) 
```

```{r}
#| eval: false
#| echo: false
search_vars_bs4dash()

search_vars_bs4dash("main color")
```

```{r}
#| echo: false
#| eval: false
#| layout-nrow: 1
#| fig-cap: "missing"
#| fig-subcap: 
#|   - "train"
#|   - "test"

missing_variables(train)
missing_variables(test)
```

```{r}
missing_loliplot(data)
```

```{r}
#| fig-cap: "missing"
#| fig-subcap: 
#|   - "train"
#|   - "test"
#| layout-nrow: 2
#| layout-ncol: 2

missing_heatmap(train)
missing_heatmap(test)
```

on observe que certaines variables ont des valeurs manquantes qui sont liées

-   **79 variables explicatives**

-   **répartition des types de variables**

```{r}
#| fig-cap: "type de variable"

# j'ai enlever integer car R compte les variables de type integer parmi les numériques.
var_type_viz_1(data)
```

# exploration des données via l'application shiny

# Visualisation des données

## Variable cible (SalePrice)

```{r}
#| echo: true

summary(train$SalePrice)

```

```{r}
var_quanti_viz_1(data = train, SalePrice)
```

```{r}
var_quanti_viz_2(data = train, var = SalePrice)
```

```{r}
var_quanti_viz_3(data = train, var = SalePrice)
```

## exemple de Variables qualitatives (MSSubClass)

```{r}
#| echo: false
a <- train %>% 
  distinct(MSSubClass) %>%
  nrow()
print(paste("il y a", a, "modalités"))
```

### distribution

```{r}
  
train$MSSubClass <- as.character(train$MSSubClass)

var_quali_viz_2(data = train, var = MSSubClass)
```

### lien avec la variable cible

```{r}
#| column: screen-inset-shaded
#| layout:  "[[1,1], [1]]"

var_cible_quali_1(train, MSSubClass, SalePrice)

var_cible_quali_3(data = train, var = MSSubClass)

var_cible_quali_2(data = train, var = MSSubClass)

```
on remarque que lavariable *MSSubClass* permet de bien discriminer la vairiable *MSSubClass*
## exemple de Variables quantitatives(LotFrontage)
```{r}
data %>% select(where(is.numeric)) %>% names()
```

```{r}
summary(train$LotFrontage)
```

```{r}
missing_viz_1(data = train, class = LotFrontage)
```

```{r}
var_quanti_viz_1(data = train, LotFrontage)
```

```{r}
var_quanti_viz_2(data = train, var = LotFrontage, adjust = 1)
```

```{r}
var_quanti_viz_3(data = train, var = LotFrontage)
```

```{r}
var_cible_quanti(data = train, var = LotFrontage)
```

# métrique d'évaluation (modèle le plus simple)

Nous choisissons dans notre étude le modèle intercepté comme modèle de référence. Le modèle qui fait l'erreur la plus grande erreur possible.

```{r}
files <- data.frame(
  Id = test$Id,
  SalePrice = rep(mean(train$SalePrice), nrow(test))
  )

# write.csv(data, file = "output.csv", row.names = FALSE)
files %>% head(6)
```

après une submission sur kaggle, on observe que le modèle le plus simple (modèle à 1 paramètre) a comme score **0.42577**

mon indicateur de performance s'inspire du $^2 = 1 - \frac{\sum_{i=1}^{n} (y_i - \hat{y}_i)^2}{\sum_{i=1}^{n} (y_i - \bar{y})^2}$

nouveau indicateur de performance : Soit $y = SalaPrice$ et $z=ln(y)$

$$indiacteur =1 - \frac{RMSE_{model d'etude}}{RMSE_{modelsimple}} = 1 - \frac{\sqrt{\frac{1}{n} \sum_{i=1}^{n} (z_i - \hat{z}_i)^2}}{\sqrt{\frac{1}{n} \sum_{i=1}^{n} (z_i - \bar{z})^2}}$$

```{r}
indicateur <- function(a){
if ( a > 0.42577 | a < 0 ){
  print("faut te revoir")
}else{
    result <- (1 - a / 0.42577) * 100
  sprintf("%.2f %%", result)
} }
```

## meilleur score actuel su kaggle

```{r}
indicateur(0.14736)
```

# Preparation des données

![](images/clipboard-3094508585.png)

## trop de données manquantes

```{r}
train <- data[1:nrow(train), ]
train$SalePrice = label
```

```{r}
#| layout-ncol: 2
missing_viz_1(data, MiscVal)
missing_viz_1(data, PoolArea)
```

```{r}
#| eval: false
data <- data %>% 
    dplyr::select( -c(MiscVal, PoolArea))
```

les variables *PoolQC* et *MiscFeature* vont nous permettre de traduire l'information contenue dans les variables supprimées en **variable binaire**.

## variable avec une modalité dominante dépassant 97%

```{r}
data <- data %>% 
      dplyr::select( -c(Street, Utilities))

```

je les suprime car non pertinentes

```{r}
var_cible_quali_1(train, Street, SalePrice)
var_cible_quali_2(train, Utilities, SalePrice)
```

-   la colonne *Id* n’est pas nécessaire pour la formation du modèle.

```{r}
data <- data %>%  dplyr::select( -c(Id) )
```

# Mosold YrSold

```{r}
levels_yr <- sort( unique(train["YrSold"] %>% pull()) )
levels_m <- sort( unique(train["MoSold"] %>% pull() ) )

train$YrSold <- as.factor(train$YrSold)
train$MoSold <- as.factor(train$MoSold)

train$YrSold <- factor(train$YrSold, levels = levels_yr)
train$MoSold <- factor(train$MoSold, levels = levels_m)


```

```{r}
var_cible_quali_1(train, MoSold, SalePrice)
var_cible_quali_1(train, YrSold, SalePrice)
```

pas très significative

```{r}
train <- train %>% 
  mutate(time = as.Date(paste0(YrSold, "-", MoSold, "-01"), format = "%Y-%m-%d"))  %>%
  select(-c(YrSold, MoSold))

sort( unique(train["time"] %>% pull()) )

library(leaflet)
navset_card_tab(
  height = 450,
  full_screen = TRUE,
  title = "évolution du prix moyen des ventes au fill des mois depuis 2016",
  nav_panel(
    "Plotly",
    card_title("A plotly plot"),
    var_cible_quali_1(train, time, SalePrice)
  ),
  nav_panel(
    "Leaflet",
    card_title("A leaflet plot"),
    var_cible_quali_1(train, time, SalePrice)
  ),
  nav_panel(
    shiny::icon("circle-info"),
    markdown("Learn more about [htmlwidgets](http://www.htmlwidgets.org/)")
  )
)


```

on a significativement augmenter la pertinence de la variable YrSold et MoSold en les combinants

mais il y a trop de modalité

essayons de les remplacer par une variable disrète de temps t corespondant au nombre de mois passés depuis la vente de la première maisons.

```{r}
reference_year <- as.numeric(format(min(train$time), "%Y"))
reference_month <- as.numeric(format(min(train$time), "%m"))

# Calculer la variable quantitative
train$quantitative_dates <- (as.numeric(format(train$time, "%Y")) - reference_year) * 12 +
  as.numeric(format(train$time, "%m")) - reference_month + 1

train %>% count(time, quantitative_dates)


```

```{r}
var_cible_quanti(train, quantitatives_dates)
```

## ancienneté absolue, ancienneté relative

```{r}
sort( unique(data["YearBuilt"] %>% pull()) )
sort( unique(data["YearRemodAdd"] %>% pull() ) )
```

```{r}
train <- train %>% mutate(abs_age =  interval(as.Date(YrSold), as.Date(YearBuilt)  ))


var_cible_quali_1(train, YearBuilt, SalePrice)
var_cible_quanti(train, YearBuilt)
```

```{r}
var_cible_quali_1(train, YearRemodAdd, SalePrice)
var_cible_quanti(train, YearRemodAdd)

```

## Convertir les variables à étiquettes en chaîne de charactère

```{r}
data$MSSubClass <- as.character(data$MSSubClass)
data$OverallQual <- as.character(data$OverallQual)
data$OverallCond <- as.character(data$OverallCond)
data$Fireplaces <- as.character(data$Fireplaces)
data$GarageCars <- as.character(data$GarageCars)
data$BsmtFullBath <- as.character(data$BsmtFullBath)
data$BsmtHalfBath <- as.character(data$BsmtHalfBath)
data$FullBath <- as.character(data$FullBath)
data$HalfBath <- as.character(data$HalfBath)
data$BedroomAbvGr <- as.character(data$BedroomAbvGr)
data$KitchenAbvGr <- as.character(data$KitchenAbvGr)
data$TotRmsAbvGrd <- as.character(data$TotRmsAbvGrd)
```

```         

### création de nouvelles variables

# housse_age
data <- data %>%
  mutate(housse_age = 2011 - YearBuilt) %>%
  dplyr::select(-YearBuilt)

data <- data %>%
  mutate(housse_age = case_when(
    0 <= housse_age & housse_age <= 10 ~ "1",
    10 < housse_age & housse_age <= 20 ~ "2",
    20 < housse_age & housse_age <= 30 ~ "3",
    30 < housse_age & housse_age <= 40 ~ "4",
    40 < housse_age & housse_age <= 65 ~ "5",
    65 < housse_age & housse_age <= 80 ~ "6",
    80 < housse_age  ~ ">80"
  ))



# garage_age
data <- data %>%
  mutate(garage_age = 2011 - GarageYrBlt) %>%
  dplyr::select(-GarageYrBlt)

data <- data %>%
  mutate(garage_age = case_when(
    is.na(garage_age) ~ "No_Garage",
    0 <= garage_age & garage_age <= 10 ~ "1",
    10 < garage_age & garage_age <= 20 ~ "2",
    20 < garage_age & garage_age <= 30 ~ "3",
    30 < garage_age & garage_age <= 40 ~ "4",
    40 < garage_age & garage_age <= 50 ~ "5",
    50 < garage_age & garage_age <= 60 ~ "6",
    60 < garage_age  ~ ">60"
  ))


# remod_since
data <- data %>%
  mutate(remod_since = 2011 - YearRemodAdd) %>%
  dplyr::select(-YearRemodAdd)

data <- data %>%
  mutate(remod_since = case_when(
    0 <= remod_since & remod_since <= 10 ~ "1",
    10 <= remod_since & remod_since <= 20 ~ "1",
    20 < remod_since & remod_since <= 40 ~ "2",
    40 < remod_since & remod_since <= 60 ~ "3",
    60 < remod_since  ~ ">60"
  ))
```

## discretisation des variables numériques

```         

# GarageArea
data <- data %>%
  mutate(GarageArea = case_when(
    is.na(GarageArea) ~ "No.Garage",
    0 <= GarageArea & GarageArea <= 400 ~ "1",
    400 < GarageArea & GarageArea <= 600 ~ "2",
    600 < GarageArea & GarageArea <= 800 ~ "3",
    800 < GarageArea  ~ ">800"
  ))


# X1stFlrSF

data <- data %>%
  mutate(X1stFlrSF = case_when(
    is.na(X1stFlrSF) ~ "No.Garage",
    0 <= X1stFlrSF & X1stFlrSF <= 750 ~ "1",
    750 < X1stFlrSF & X1stFlrSF <= 1000 ~ "2",
    1000 < X1stFlrSF & X1stFlrSF <= 1250 ~ "3",
    1250 < X1stFlrSF & X1stFlrSF <= 1500 ~ "4",
    1500 < X1stFlrSF & X1stFlrSF <= 2000 ~ "5",
    2000 < X1stFlrSF  ~ ">2000"
  ))




# TotalBsmtSF
data <- data %>%
  mutate(TotalBsmtSF = case_when(
    TotalBsmtSF == 0 ~ "No.Basement",
    0 < TotalBsmtSF & TotalBsmtSF <= 300 ~ "1",
    300 <= TotalBsmtSF & TotalBsmtSF <= 600 ~ "2",
    600 < TotalBsmtSF & TotalBsmtSF <= 900 ~ "3",
    900 < TotalBsmtSF & TotalBsmtSF <= 1200 ~ "4",
    1200 < TotalBsmtSF & TotalBsmtSF <= 1500 ~ "5",
    1500 < TotalBsmtSF  ~ ">1500"
  ))




# BsmtFinSF1
data <- data %>%
  mutate(BsmtFinSF1 = case_when(
    BsmtFinSF1 == 0 ~ "No.Basement",
    0 < BsmtFinSF1 & BsmtFinSF1 <= 250 ~ "1",
    250 <= BsmtFinSF1 & BsmtFinSF1 <= 500 ~ "2",
    500 < BsmtFinSF1 & BsmtFinSF1 <= 750 ~ "3",
    750 < BsmtFinSF1 & BsmtFinSF1 <= 1000 ~ "4",
    1000 < BsmtFinSF1 & BsmtFinSF1 <= 1500 ~ "5",
    1500 < BsmtFinSF1  ~ ">1500"
  ))




# BsmtUnfSF
data <- data %>%
  mutate(BsmtUnfSF = case_when(
    BsmtUnfSF == 0 ~ "No.Basement",
    0 < BsmtUnfSF & BsmtUnfSF <= 500 ~ "1",
    500 < BsmtUnfSF & BsmtUnfSF <= 1000 ~ "2",
    1000 < BsmtUnfSF   ~ ">1000"
  ))







# GrLivArea
data <- data %>%
  mutate(GrLivArea = case_when(
    0 <= GrLivArea & GrLivArea <= 700 ~ "1",
    700 < GrLivArea & GrLivArea <= 1000 ~ "2",
    1000 < GrLivArea & GrLivArea <= 1300 ~ "3",
    1300 < GrLivArea & GrLivArea <= 1600 ~ "4",
    1600 < GrLivArea & GrLivArea <= 1800 ~ "5",
    1800 < GrLivArea & GrLivArea <= 2100 ~ "6",
    2100 < GrLivArea & GrLivArea <= 2800 ~ "7",
    2800 < GrLivArea  ~ ">2800",
  ))




# X2ndFlrSF
data <- data %>%
  mutate(X2ndFlrSF = case_when(
    X2ndFlrSF == 0 ~ "No_2nd_floor",
    0 < X2ndFlrSF & X2ndFlrSF <= 500 ~ "0-500",
    500 < X2ndFlrSF & X2ndFlrSF <= 1000 ~ "500-1000",
    1000 < X2ndFlrSF & X2ndFlrSF <= 1500 ~ "1000-1500",
    1500 < X2ndFlrSF  ~ ">1500",
  ))
```

### binarisation/discretisation \[Yes, No \] ?

on va donc scinder les variables qui voient leur R2 amélioré après la binarisation

```{r}
data <- data %>%
  mutate( OpenPorchSF = ifelse(OpenPorchSF == 0, "No", "Yes"),
          EnclosedPorch = ifelse(EnclosedPorch == 0, "No", "Yes"),
          X3SsnPorch =  ifelse(X3SsnPorch == 0, "No", "Yes"),
          ScreenPorch = ifelse(ScreenPorch == 0, "No", "Yes"),
          LowQualFinSF = ifelse(LowQualFinSF == 0, "No", "Yes"),
          BsmtFinSF2 = ifelse(BsmtFinSF2 == 0, "No", "Yes")
          )


data <- data %>%
  mutate(WoodDeckSF = case_when(
    WoodDeckSF == 0 ~ "No_WoodDeckSF",
    0 < WoodDeckSF & WoodDeckSF <= 100 ~ "0-100",
    100< WoodDeckSF & WoodDeckSF <= 200 ~ "100-200",
    200< WoodDeckSF & WoodDeckSF <= 300 ~ "200-300",
    300 < WoodDeckSF  ~ ">200",
  )) %>%
mutate(WoodDeckSF = fct_relevel(WoodDeckSF, "No_WoodDeckSF", "0-100", "100-200", "200-300", ">200" ))
```

::: {.callout-caution title="justification" collapse="true"}
on va donc scinder les variables qui voient leur R2 amélioré après la binarisation

```{r}
RMSE <- function(y_pred, y) {
  sse <- sum((y_pred - y)^2)
  n <- length(y)
  rmse <- sqrt(sse / n)
  return(rmse)
}

rmse_of_reference_model_on_train <- RMSE(rep(mean(label), times = nrow(train)), label)
rmse_of_reference_model_on_train
```

sur les donnée de train, le rmse du modèles de reférence est : Puisque le projet kaggle sera évalué en rmse, alor on va construire un indicateur autour du rmse de la base train.

on analyse les variables qui pourraient être transformée en variables binaires pour vérifer si cette transformation améliore ou réduit la variance

::: callout-important
Please switch `{{shinylive-r}}` to `{shinylive-r}`. We've suppressed this example from running by using `{{}}`.
:::

```{r}
a <- train %>%
  mutate( OpenPorchSF = ifelse(OpenPorchSF == 0, "No", "Yes") )
var_cible_quanti(train, OpenPorchSF)
var_cible_quali_1(a, OpenPorchSF, SalePrice)
```

```{r}
a <- train %>%
  mutate( EnclosedPorch = ifelse(EnclosedPorch == 0, "No", "Yes") )
var_cible_quanti(train, EnclosedPorch)
var_cible_quali_1(a, EnclosedPorch, SalePrice)
```

```{r}
a <- train %>%
  mutate( X3SsnPorch = ifelse(X3SsnPorch == 0, "No", "Yes") )
var_cible_quanti(train, X3SsnPorch)
var_cible_quali_1(a, X3SsnPorch, SalePrice)

#la binarisation n'apporte rien,
```

```{r}
a <- train %>%
  mutate( ScreenPorch = ifelse(ScreenPorch == 0, "No", "Yes") )
var_cible_quanti(train, ScreenPorch)
var_cible_quali_1(a, ScreenPorch, SalePrice)
#la binarisation n'apporte rien,
```

```{r}
a <- train %>%
  mutate( LowQualFinSF = ifelse(LowQualFinSF == 0, "No", "Yes") )
var_cible_quanti(train, LowQualFinSF)
var_cible_quali_1(a, LowQualFinSF, SalePrice)

#la binarisation n'apporte rien,
```

```{r}
a <- train %>%
  mutate( BsmtFinSF2 = ifelse(BsmtFinSF2 == 0, "No", "Yes") )
var_cible_quanti(train, BsmtFinSF2)
var_cible_quali_1(a, BsmtFinSF2, SalePrice)
#la binarisation n'apporte rien,
```

```{r}
a <- train %>%
  mutate( PoolArea = ifelse(PoolArea == 0, "No", "Yes") )
var_cible_quanti(train, PoolArea)
var_cible_quali_1(a, PoolArea, SalePrice)
#la binarisation n'apporte rien,
```

![](images/clipboard-3309648882.png)

je suppose que les terrasses qui ont une valeur dans un intervale de 100 ont plus ou moins le même prix. et qu'il faut en moyenne 100 m\^2 de plus à la surface de la terasse pour avoir un impact significatif sur le prix

```{r}
# WoodDeckSF
a <- train %>%
  mutate(WoodDeckSF = case_when(
    WoodDeckSF == 0 ~ "No_WoodDeckSF",
    0 < WoodDeckSF & WoodDeckSF <= 100 ~ "0-100",
    100< WoodDeckSF & WoodDeckSF <= 200 ~ "100-200",
    200< WoodDeckSF & WoodDeckSF <= 300 ~ "200-300",
    300 < WoodDeckSF  ~ ">200",
  )) %>%
mutate(WoodDeckSF = fct_relevel(WoodDeckSF, "No_WoodDeckSF", "0-100", "100-200", "200-300", ">200" ))


var_cible_quanti(train, WoodDeckSF)
var_cible_quali_1(a, WoodDeckSF, SalePrice)
```
:::

## outlier

```{r}
Q3 <- quantile(data$LotArea, 0.75)
seuil <- 20000
# Utiliser dplyr pour remplacer automatiquement les valeurs
data <- data %>%
  mutate(LotArea = if_else(LotArea > seuil, 1.5*as.numeric(Q3), LotArea))
```

::: {.callout-caution title="justification" collapse="true"}
```{r}
var_cible_quanti(train , LotArea)

Q3 <- quantile(train$LotArea, 0.75)
seuil <- 20000
train_corrigees <- train %>%
  mutate(LotArea = if_else(LotArea > seuil, 1.5*as.numeric(Q3), LotArea))

var_cible_quanti(train_corrigees , LotArea)
```

```{r}
var_cible_quanti(train, MasVnrArea)
var_cible_quanti(train, BsmtFinSF1)
var_cible_quanti(train, BsmtUnfSF)
```
:::

## Mising value

```{r}
#| layout-nrow: 2
#| layout-ncol: 2

missing_loliplot(data)

missing_variables(data)


# gg_miss_case(train)
hist(n_miss_row(data), xlab = "", main =  "Histograme du nombre de valeurs manquantes par ligne")

missing_heatmap(data)
```

#### certaines NA ont une raisons connues d'être

toute valeur manquante informative doit être remplacé par l'information qu'elle contient

```{r}
data <- data %>%
  mutate(
    Alley = ifelse(is.na(Alley), "No.alley.access", Alley),
    
    BsmtQual = ifelse(is.na(BsmtQual), "No.Basement", BsmtQual),
    BsmtCond = ifelse(is.na(BsmtCond), "No.Basement", BsmtCond),
    BsmtExposure = ifelse(is.na(BsmtExposure), "No.Basement", BsmtExposure),
    BsmtFinType1 = ifelse(is.na(BsmtFinType1), "No.Basement", BsmtFinType1),
    BsmtFinType2 = ifelse(is.na(BsmtFinType2), "No.Basement", BsmtFinType2),
    
    MiscFeature = ifelse(is.na(MiscFeature), "None", "Yes"),
    Fence = ifelse(is.na(Fence), "None", Fence),
    FireplaceQu = ifelse(is.na(FireplaceQu), "No.Fireplace", FireplaceQu),
    
    GarageType = ifelse(is.na(GarageType), "No.Garage", GarageType),
    GarageFinish = ifelse(is.na(GarageFinish), "No.Garage", GarageFinish),
    GarageQual = ifelse(is.na(GarageQual), "No.Garage", GarageQual),
    GarageCond = ifelse(is.na(GarageCond), "No.Garage", GarageCond),

    PoolQC = ifelse(is.na(PoolQC), "No.Pool", "Yes")
  )
```

```{r}
sum(is.na(data))
# 715
```

# Identifier les modalités communes

```{r}
data <- data %>%
  mutate(across(where(is.factor), as.character))

cat_data <- data %>% select_if(is.character)

cat_vars <- cat_data %>% colnames()

for (i in cat_vars) {
      data1 <- data[1:nrow(train), ]
      levels1 <- data1[[i]] %>% unique() %>% as.character()
      
      data2 <-  data[(nrow(train) + 1):nrow(data) , ]
      
      levels2 <- data2[[i]] %>% unique() %>% as.character()
      
      # Identifier les modalités communes
      common_levels <- intersect(levels1, levels2)
      factor <- data[[i]] %>% as.character()
      data[[i]] <- ifelse( !factor %in% common_levels, NA, factor   ) 
}

 
```

```{r}
data <- data %>% select(-type)
```

```{r}
missing_heatmap(data)
```

```{r}
sum(is.na(data))
```

#### Missforest for other NA input

Missforest permet d'imputer les valeurs manquantes dans les jeux de données de type **mixte** en utilisant les **forêts aléatoires** pour prédire les valeurs manquantes de manière itérative et non paramétrique, en tirant parti des relations entre les variables.

missForest surpasse les autres méthodes d'imputation, en particulier dans les contextes de données où des interactions complexes et des relations non linéaires sont suspectées.

![](images/clipboard-4011442430.png)

je prépare mes données pour l'algorithme

```{r}
# Transformer toutes les colonnes de type caractère en facteur
data <- data %>%
  mutate(across(where(is.character), as.factor))
         
var_type_viz_1(data)

```

```{r}
library(missForest)
# data.imp <- missForest(data, verbose = TRUE, maxiter = 8 , ntree = 50, replace = TRUE)
data <- read.csv("inputed_data.csv", na.strings = "NA")
```

```{r}
#colSums(is.na(data.imp$ximp))
```

## on enlève les modalités des variables cateégorielles et on les rempplace par des valeur manquantes qu'on va inputer à nouveau par la methode de miss forest.

```{r}
#data <- data.imp$ximp
#sum(is.na(data))

```

```{r}
data$MSSubClass <- as.character(data$MSSubClass)
data$OverallQual <- as.character(data$OverallQual)
data$OverallCond <- as.character(data$OverallCond)

data$Fireplaces <- as.character(data$Fireplaces)
data$GarageCars <- as.character(data$GarageCars)
data$BsmtFullBath <- as.character(data$BsmtFullBath)
data$BsmtHalfBath <- as.character(data$BsmtHalfBath)

data$FullBath <- as.character(data$FullBath)

data$HalfBath <- as.character(data$HalfBath)
data$BedroomAbvGr <- as.character(data$BedroomAbvGr)
data$KitchenAbvGr <- as.character(data$KitchenAbvGr)


data$TotRmsAbvGrd <- as.character(data$TotRmsAbvGrd)

data$MoSold <- as.character(data$MoSold)

data <- data %>%
  mutate(across(where(is.integer), as.numeric)) %>%
  mutate(across(where(is.character), as.factor))

var_type_viz_1(data)
```
```{r}
cat_corelation_heatmap(data = train)
#write.csv(data.imp$ximp, file = "inputed_data.csv", row.names = FALSE)
```

```{r}
#| eval: false
#| echo: false
data <- read.csv("inputed_data.csv", na.strings = "NA")
sum(is.na(data))
```

# CART

elles sont assez performantes, non paramétriques et non linéaires. Dans le principe, elles vont partitionner les individus en produisant des groupes d’individus les plus homogènes possible du point de vue de la variable à prédire, en tenant compte d’une hiérarchie de la capacité prédictive des variables considérées.

à chaque itéaration, une variable et le seuil de division qui offrent la meilleure séparation sont choisis, et les données sont divisées en deux sous-groupes (nœuds enfants).

donc l'algorythme CART réalisé sur une variable pourait être un bon indicateur sur les bornes de dicretisation afin de créer des groupes homogènes et distincts.

Ce code permet de voir si c'est une bonne idée de discrétiser une variable ou non, donc à partir du split optimal, on calcul le R2 en considérant la moyenne de chaque classe comme une prediction du modèle

```{r}
train <- data[1:nrow(train), ]
train$SalePrice = label

create_report(
  train,
  output_format = html_document(toc = TRUE, toc_depth = 6, theme = "yeti"),
  output_file = "report.html",
  output_dir = getwd(),
  y = "SalePrice",
  config = configure_report(),
  report_title = "Data Profiling Report")
```

## discrestisation par CART

les dernières lignes permetent de savoir quelles sont les moyennes des diférents noeud et le mse associé à chaque node si la moyenne du node etait la prediction

```{r}
cart_model <- rpart(SalePrice ~ LotArea, data = train, method = "anova")       
#summary(cart_model)

# Assigner chaque observation à un nœud
train$node <- cart_model$where

# Calculer la moyenne de chaque nœud
node_means <- aggregate(SalePrice ~ node, data = train, FUN = mean)
names(node_means)[2] <- "NodeMean"

# Fusionner les moyennes des nœuds avec les données d'origine
train <- merge(train, node_means, by = "node")
```

```{r}
disc <- is_discretisable(train, LotArea, SalePrice)
cuts <- sort(disc$cuts)

cuts
```

```{r}
cuts <- sort(cuts)

num_intervals <- length(cuts) + 1
 
interval_labels <- paste0("class_", 1:num_intervals)

train$class <- cut(train$LotArea, breaks = c(-Inf, cuts, Inf), labels = interval_labels)


train$class <- factor(train$class, levels = interval_labels)

discretise <- function( data, var, cuts){
  num_intervals <- length(cuts) + 1
 
interval_labels <- paste0("class_", 1:num_intervals)

train$class <- cut(train$LotArea, breaks = c(-Inf, cuts, Inf), labels = interval_labels)


train$class <- factor(train$class, levels = interval_labels)

}
```

comparaison de LotArea discrétisé et LotArea continue

```{r}
var_cible_quali_1(train, class, SalePrice)
```

```{r}
var_cible_quanti(train, LotArea)
```

# étudions l'effe de chaque variable qualitative sur le prix

par le test ANOVA


```{r}
categorical_corelation(train)
```








